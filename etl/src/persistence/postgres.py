import logging

import pandas as pd
from sqlalchemy.dialects.postgresql import insert as pg_insert

from persistence.db import Db


class Postgres(Db):
    def __init__(self, credentials_file_path: str):
        super(Postgres, self).__init__(credentials_file_path)

    def get_connection_string(self) -> str:
        (database, address, user, password, port) = self._credentials.astuple()
        connection_str = f"postgresql+psycopg2://{user}:{password}@{address}:{port}/{database}"

        return connection_str

    def upsert(self, data: pd.DataFrame, schema_name: str, table_name: str, action: str = "ignore"):
        """
        Prepares and executes a PostgreSQL INSERT ON CONFLICT...DO NOTHING
        or DO UPDATE statement via sqlalchemy.dialects.postgresql.insert

        @param data:
        @param schema_name:
        @param table_name:
        @param action: {update|ignore}
            * If 'update' issues a ON CONFLICT...DO UPDATE statement
            * If 'ignore' issues a ON CONFLICT...DO NOTHING statement
        @return:
        """

        if len(data) == 0:
            return

        try:
            engine = self._engine()
            connection = engine.connect()
            transaction = None
        except Exception:
            logging.error("There was an issue connecting to a database")
            raise

        try:
            transaction = connection.begin()

            # pd.io.sql not found
            # noinspection PyUnresolvedReferences
            pandas_sql_engine = pd.io.sql.SQLDatabase(
                engine=engine,
                schema=schema_name
            )

            # we assume, that for classes, where primary key columns is present, but is not set explicitely
            # it should be generated by a database identity trigger on insert
            if "id" in data and data["id"].count() < len(data):
                data = data.drop("id", axis=1)

            # pd.io.sql not found
            # noinspection PyUnresolvedReferences
            table = pd.io.sql.SQLTable(
                name=table_name,
                schema=schema_name,
                pandas_sql_engine=pandas_sql_engine,
                frame=data
            ).table

            values = data.to_dict(orient="records")
            insert_stmt = pg_insert(table).values(values)

            if action == "ignore":
                upsert = insert_stmt.on_conflict_do_nothing()
            elif action == "update":
                # TODO: update doesn't work as pandas fails to get constraints information
                # TODO: we also need to get information on unique contraints to use them in "on conflict" statement
                update_cols = [c.name for c in table.c if c not in list(table.primary_key.columns)]

                upsert = insert_stmt.on_conflict_do_update(
                    index_elements=table.primary_key.columns,
                    set_={col: getattr(insert_stmt.excluded, col) for col in update_cols}
                )
            else:
                raise Exception(f"Unknown action {action}. Should be one of ('ignore', 'update')")

            connection.execute(upsert)

            transaction.commit()
        except Exception:
            if transaction is not None:
                transaction.rollback()

            logging.error(f"There was an issue appending {len(data)} rows to {schema_name}.{table_name} table")
            raise
        finally:
            connection.close()
